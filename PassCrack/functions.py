"""Module to select hashing algorithm, wordlist and  """
import hashlib

from urllib.request import urlopen
from urllib.error import URLError, HTTPError


def hash_choice():
    """
    Makes user enter 1 of 6 algorithm choices.

    This function prompts the user to choose an encryption algorithm
    and validates the input against a list of valid choices. 
    It continues to prompt the user until a valid choice is provided.

    Returns:
        str: The chosen encryption algorithm (e.g., "md5", "sha256").
    """
    while True:
        # Prompt the user to choose an encryption algorithm
        algorithm_choice = input("Choose encryption: ").lower()

        # Check if the user's choice is in the list of valid algorithms
        if algorithm_choice in [
            "md5", "sha1", "sha224", "sha256", "sha384", "sha512", 
            "blake2b", "blake2s", "sha3_224", "sha3_256", "sha3_384",
            "sha3_512", "shake_128", "shake_256"
        ]:
            # If the choice is valid, return the chosen algorithm
            return algorithm_choice
        else:
            print("Please enter a valid choice")
#EOF


def wordlist_choice():
    """
    Gives user options as to which wordlist to choose

    Returns:
    list of str: The list of words which will be used as a crosschecker
    for any hash.
    """
    while True:
        # Accepts input as a "1,2 or 3". Each path could be remade into
        # its own funtion
        which_wordlist = input(
            "1. Path to wordlist. | "
            "2. URL | "
            "3. Use Hash Cracker list\nChoose:   "
        )

        # If the user chooses to input a path
        if which_wordlist == "1":
            path = input("Enter path:   ")

            # Open the file and read its content, save read content as
            # variable "wordlist"
            with open(path, encoding="utf-8") as wordlist_file:
                wordlist = wordlist_file.read()

            # Check if wordlist is already a list;
            # if not, convert it to a list
            if isinstance(wordlist, list):
                wordlist_formatted = wordlist
            else:
                wordlist_formatted = wordlist.split("\n")

            # Returns a formatted worldist
            return wordlist_formatted

        # If the user chooses to fetch a wordlist from a URL. Needs to
        # be in a raw text format.
        elif which_wordlist == "2":
            url = input("Enter URL:   ")

            # read_wordlist_url returns a utf-8 decoded text or prints
            # pertinent errors
            list_from_url = read_wordlist_url(url)

            # Check if the wordlist is already a list;
            # if not, convert it to a list
            if isinstance(list_from_url, list):
                wordlist_formatted = list_from_url
            else:
                wordlist_formatted = list_from_url.split("\n")

            # Returns a formatted wordlist
            return wordlist_formatted

        # If the user chooses an embedded wordlist, currently 3 choices
        elif which_wordlist == "3":

            #While loop to allow for mistakes in choosing "1,2 or 3"
            while True:
                choose_embedded = input(
                    " 1. MIT - 10.000 words "
                    "| 2. Berzerk0 - top 12.000  "
                    "| 3. rockyou  \nChoose:  "
                    )
                # A bad way of checking to see if choose_embedded gives
                # correct input
                if choose_embedded in ["1", "2", "3"]:

                    # choice = 1.MIT -10.000 words
                    if choose_embedded == "1":

                        # read_wordlist_url returns a utf-8 decoded
                        # text or prints pertinent errors
                        mit_10000 = read_wordlist_url(
                            r"https://www.mit.edu/~ecprice/wordlist.10000"
                        )

                        # Check if the wordlist is already a list;
                        # if not, convert it to a list
                        if isinstance(mit_10000, list):
                            wordlist_formatted = mit_10000
                        else:
                            wordlist_formatted = mit_10000.split("\n")

                        # Returns a formatted wordlist
                        return wordlist_formatted

                    # choice = 2. Berzerk0
                    elif choose_embedded == "2":

                        # read_wordlist_url returns a utf-8 decoded
                        # text or prints pertinent errors
                        berzerk0 = read_wordlist_url(
                            r"https://raw.githubusercontent.com/berzerk0/"
                            r"Probable-Wordlists/master/Real-Passwords/"
                            r"Top12Thousand-probable-v2.txt"
                        )

                        # Check if the wordlist is already a list;
                        # if not, convert it to a list
                        if isinstance(berzerk0, list):
                            wordlist_formatted = berzerk0
                        else:
                            wordlist_formatted = berzerk0.split("\n")

                        # Returns a formatted wordlist
                        return wordlist_formatted

                    # choice = 3. rockyou
                    elif choose_embedded == "3":

                        # Specify the path for the rockyou wordlist
                        path = (
                            "C:\\Users\\sydga\\Desktop\\Skola\\5. Python"
                            "\\PentestToolbox\\Pass_Crack\\rockyou.txt"
                        )

                        # Read the rockyou wordlist from the specified path
                        with open(path, 'r', encoding='utf-8') as rockyou_file:
                            rockyou = rockyou_file.read()

                        # Check if the wordlist is already a list;
                        # if not, convert it to a list
                        if isinstance(rockyou, list):
                            wordlist_formatted = rockyou
                        else:
                            wordlist_formatted = rockyou.split("\n")

                        # Returns a formatted wordlist
                        return wordlist_formatted
                else:
                    print("Choose you goose")
#EOF


def read_wordlist_url(url):
    """
    URL as arg and returns a utf-8 text or prints defined errors.

    Parameters:
    - url (str): A URL to a online wordlist
    
    Returns:
    str: A unicode version of the webpage
    """
    try:
        with urlopen(url) as response:
            list_from_url = response.read().decode("utf-8")

        return list_from_url

    # URLError = if given a faulty URL or lacking internet connection
    # HTTP = 404, 500 codes etc.
    # Unicode = if other than utf-8
    except (URLError, HTTPError, UnicodeDecodeError) as error:
        print("Exception error:", error)
        exit()
#EOF


def password_hasher(wordlist_guess, algorithm="sha1"):
    """
    Hashing cleartext, turns cleartext into hashes, 
    this is done to the wordlist in order to 
    compare to the acquired hash.

    Parameters:
    - Wordlist_guess (str): An instance of wordlist_formatted
    - algorithm (str): The algorithm choice previosusly provided

    Return
    str: The hash of whatever word was entered using whatever hashing
         technique chosen.
    """
    # Checks to see if the hash-choice we made earlier actually is a
    # valid choice included in hashlib. If not it returns a error
    if algorithm not in hashlib.algorithms_available:
        raise ValueError("Invalid hashing algorithm")

    # Creates the new hash and updates the variable with an encoded
    # (hashed) version of wordlist_guess
    hash_object = hashlib.new(algorithm)
    hash_object.update(wordlist_guess.encode())

    # Returns a hashed version of the word given by bruteforce()
    # if shake_128 or 256, .hexdigest(length)
    return hash_object.hexdigest()
#EOF



def bruteforce(wordlist_formatted, acquired_hash, algorithm):
    """
    Combines everything so far and does the actual hash cracking.
    Calls upon the password_hasher() function to encrypt each word in a
    wordlist. Then compares the hashed version of the word to the hash
    previously entered, if they're the same: Bingo! if not, then try
    the next word. If no more words return None.

    Parameters:
    - Wordlist_formatted (list): the reslut of which_worldlist(). Can 
        use any list of str.
    - acquired_hash (str): Whatever the user has entered previously in
        the main function.
    - algorithm (str): This can be any string but is previously vetted
        to be one of hashlibs incorporated algorithms.

    Returns:
    str: The word which when hashed matches the acquired_hash.
    NoneType: Returns None if nothing matches.   
    """
    for wordlist_guess in wordlist_formatted:
        if password_hasher(wordlist_guess, algorithm) == acquired_hash:
            return wordlist_guess
#EOF
